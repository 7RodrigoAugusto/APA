#	----	Observações
#	Utilizando degree
#	-------------------

#	----	Bibliotecas
#Para realizar a escolha aleatória de uma aresta
import random

#	----	Conjunto de vértices
#Set de vértices que abrange a menor quantidade de arestas possível

# --- Utilizado para o vertex cover
conj_vertices = set()

# --- Utilizado para calcular o grau dos vértices
conj_vertex = set()
dic_vertices = {}

'''
conj_vertex = set()
class vertice:
     def __init__(self, u, g):
         self.u = u
         self.g = g	#grau do vértice
'''

#	----	Classe aresta
class aresta:
     def __init__(self, u, v):
         self.u = u
         self.v = v

#	-----	Conjunto que contém todas as arestas         
conj_arestas = []


#	-----	Função para abrir arquivos e criar o conjunto de arestas
def abreArquivo():
	txt = open('frb30-15-mis/frb30-15-1 copy.mis','r').readlines()
	array = []
	i = 0
	for item in txt:
		if i == 0:
			vetor_aux = item.strip('\n').split(' ')
			qtd_vertices, qtd_arestas= int(vetor_aux[2]),int(vetor_aux[3])
			i = i + 1
			pass
		else:
			vetor_aux = item.strip('\n').split(' ') 
			conj_arestas.append(aresta(vetor_aux[1],vetor_aux[2]))
			array.append(vetor_aux)	#Removo o \n de cada elemento do array
	
	return array, qtd_vertices, qtd_arestas


#	-----	Função para printar as arestas durante os testes
def print_arestas():
	print(" ------------------------------ \n")
	print("Quantidade de arestas:",len(conj_arestas))
	print("Arestas existentes: \n")
	for obj in conj_arestas:
		print(obj.u,obj.v)
	
	print(" ------------------------------ \n")
	return	

	
#	-----	Cálcula o grau de importância de cada vértice
def vertex_grau():
	# PRECISO ENCONTRAR UMA FORMA DE LIMPAR SEM PREJUDICAR O CÓDIGO
	#dic_vertices = {}
	#conj_vertex.clear()
	for aresta in conj_arestas:
		if	aresta.u not in conj_vertex:
			conj_vertex.add(aresta.u)
			dic_vertices[aresta.u] = 0
		if aresta.v not in conj_vertex:
			conj_vertex.add(aresta.v)
			dic_vertices[aresta.v] = 0
		if aresta.u in conj_vertex:
			dic_vertices[aresta.u] = dic_vertices[aresta.u] + 1
		if aresta.v in conj_vertex:
			dic_vertices[aresta.v] = dic_vertices[aresta.v] + 1
		else: 
			pass
	return

# -----	Retorna os dois melhores vértices que possuem uma aresta 
def vertex_melhor():
	aux_maior = 0
	for item in dic_vertices:
		if dic_vertices[item] > aux_maior: 
			aux_maior = int(item)	# Item do dicionario com maior valor
	return aux_maior	# Retorna o melhor vértice

# -----	Escolho uma aresta que contenha o melhor vértice	
def	aresta_melhor(x):
	for item in conj_arestas:
		if int(item.u) == x:
			conj_vertices.add(item.u)
			conj_vertices.add(item.v)
			break
		elif int(item.v) == x:
			conj_vertices.add(item.u)
			conj_vertices.add(item.v)
			break
		else:
			pass
	return

#	-----	Função que excluí arestas e adiciona vértices em um conjunto
def vertex_cover():	
	#Enquanto existirem arestas x
	while conj_arestas:	
		# --- Cálcula o grau de importância de cada vértice naquele momento
		vertex_grau()
		print("Dicionário dos vértices com seu grau:",dic_vertices)
		
		# - Encontro o vértice com maior grau
		melhor = vertex_melhor()
		print("Melhor vértice: ",melhor)
		
		# - Escolho uma aresta que contenha esse vértice
		melhor_aresta = aresta_melhor(melhor)
		print("Aresta escolhida:", conj_vertices)

		quit()	
		# - Devo priorizar a escolha do melhor vértice 
		#aux = random.choice(conj_arestas) 
		#conj_vertices.add(aux.u)
		#conj_vertices.add(aux.v)
		
		print("Conj de vértices: ",conj_vertices)
		
		#Agora devo remover as arestas que possuem ligação com esses vértices
		for item in conj_arestas:
			#print(item.u,item.v)
			#Se eu quiser deixar as arestas dos vértices que pertencem
			if item.u in conj_vertices and item.v in conj_vertices:
				#print("Remove", item.u, item.v)
				conj_arestas.remove(item)
				#pass
			elif item.u in conj_vertices or item.v in conj_vertices:
				#print("Remove", item.u, item.v)
				conj_arestas.remove(item)
			else:
				#print("Fica", item.u, item.v)
				pass
	
	return	
	
#	-----	main
def main():
	elementos, qtd_vertices, qtd_arestas = abreArquivo()
	print("Quantidade inicial de vértices: \n",qtd_vertices)
	
	print("Inicialmente temos:",len(conj_arestas),"arestas\n")
	
	# --- Apresenta o conjunto de arestas atual
	#print_arestas()
	
	
	# --- PRECISO FICAR CHAMANDO ESSE FUNCAO VERTEX COVER ENQUANTO O OBJETIVO NÃO FOR ATINGIDO
	#while ... chama vertex cover
		#vertex_grau()
	vertex_cover()
	
	print("Conjunto final de vértices escolhidos: \n",conj_vertices)		
	print("Tamanho:\n",len(conj_vertices))	
	
	return
	
	
main()
